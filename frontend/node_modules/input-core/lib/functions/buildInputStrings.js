"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var CharTypesEnum_1 = require("../constants/CharTypesEnum");
function buildInputStrings(data, mask, input, maskChar, maskString, selection) {
    var value = [];
    var valueIndex = 0;
    var pastedIndex = 0;
    var maskedValue = '';
    var inputValuesApplied = 0;
    function processMaskPartAsChar(maskPart, pastedValuesStack, item) {
        // if user inputs value, we check it, but we don't go through all stack
        if (pastedValuesStack && pastedValuesStack[0] === maskPart.char) {
            pastedIndex++;
        }
        else {
            if ((item && (item.char === maskPart.char || item.type !== CharTypesEnum_1.CharTypes.USER)) || input) {
                valueIndex++;
            }
        }
        value.push({
            char: maskPart.char,
            type: CharTypesEnum_1.CharTypes.CHAR,
        });
        if (pastedValuesStack) {
            inputValuesApplied++;
        }
        maskedValue += maskPart.char;
    }
    function processMaskPartAsRegExp(maskPart, maskIndex, pastedValuesStack, item) {
        var part = null;
        // If we have the value inputted by user, check it.
        // We have to move through the whole stack, to find suitable
        if (pastedValuesStack) {
            var i = 0;
            while (!maskPart.regexp.test(pastedValuesStack[i]) && pastedValuesStack.length > i) {
                i++;
                pastedIndex++;
            }
            if (pastedValuesStack.length > i) {
                pastedIndex++;
                inputValuesApplied++;
                // Ignore previous value from the input
                valueIndex++;
                part = pastedValuesStack[i];
                value.push({
                    char: part,
                    type: CharTypesEnum_1.CharTypes.USER,
                });
                maskedValue += part;
            }
        }
        if (part) {
            return;
        }
        // User input doesn't have data or it's invalid.
        // Try to apply the previous data, or change them to the placeholder
        // if shift happened, pass excess values
        if (item && item.type === CharTypesEnum_1.CharTypes.CHAR && data.length > valueIndex + 1) {
            valueIndex++;
            processMaskItem(maskPart, maskIndex);
            return;
        }
        if (item && item.type === CharTypesEnum_1.CharTypes.USER && maskPart.regexp.test(item.char)) {
            value.push({
                char: item.char,
                type: CharTypesEnum_1.CharTypes.USER,
            });
            maskedValue += item.char;
            valueIndex++;
            return;
        }
        part = maskString ? maskString[maskIndex] : maskChar;
        value.push({
            char: part,
            type: CharTypesEnum_1.CharTypes.MASK,
        });
        if (data.length > maskIndex) {
            valueIndex++;
        }
        maskedValue += part;
    }
    // we use closures here to mutate variables, so that it increases the performance.
    function processMaskItem(maskPart, maskIndex) {
        var item = data.length > valueIndex ? data[valueIndex] : null;
        var pastedValuesStack = null;
        if (selection.start <= maskIndex && pastedIndex < input.length) {
            pastedValuesStack = input.slice(pastedIndex);
        }
        // process hardcoded char to the mask
        if (maskPart.char) {
            return processMaskPartAsChar(maskPart, pastedValuesStack, item);
        }
        // text by regexp
        if (maskPart.regexp) {
            return processMaskPartAsRegExp(maskPart, maskIndex, pastedValuesStack, item);
        }
    }
    mask.forEach(function (maskPart, maskIndex) {
        processMaskItem(maskPart, maskIndex);
    });
    return {
        value: value,
        maskedValue: maskedValue,
        inputValuesApplied: inputValuesApplied,
    };
}
exports.buildInputStrings = buildInputStrings;

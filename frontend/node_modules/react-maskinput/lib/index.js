"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = require("react");
var input_core_1 = require("input-core");
var KEYBOARD = {
    BACKSPACE: 8,
    DELETE: 46,
};
/**
 * React-MaskInput component
 * Params:
 * `mask`: String. Format:
 *   0 — any number 0-9
 *   * — any symbol
 *   a — A-Z, a-z
 *   q — "q" letter, 2 — "2" letter etc.
 *   \a — "a" letter
 * default is undefined
 *
 * [function] `reformat`: user function, if you want use custom reformat logic. It's userfull for numeric inputs.
 * If reformat defined mask'll be ignored. Reformat function must receive object with several fields:
 * function reformat({data: data, selection: {start, end}, input}) {
 *     // realisation
 *
 *     return {
 *         [any] value: value that store and calling in input core funcitons (such as reformat). value may have any format,
 *         [String] visibleValue: value that displayed to user in input if showMask is false,
 *         [String] maskedValue: value that  displayed to user in input if showMask is true,
 *         [{[integer] start, [integer] end}] selection: {start, end} — new selection range
 *     }
 * }
 *
 * if `reformat` and `mask` is undefined, input allow to enter any values.
 *
 * You can define custom mask by passing `maskFormat`. This prop must be an array,
 * each object in array have several fields:
 * str: matched char for mask
 * regexp: validation rule as regexp
 * type: special
 *
 * `maskChar`: Character to cover unfilled editable parts of mask. Default value is ''.
 * `maskString`: String to cover unfilled editable parts of mask. Default is undefined. If maskString define maskChar ignored.
 *
 * showMask: show mask in input. It's possible only if mask have not cyclic. Default value = false
 * alwaysShowMask: show mask when input inactive
 *
 * Callbacks:
 *   onValueChange(event). event is:
 *     maskedValue: masked value,
 *     value: value without nessesary mask
 *   getReference: callback to get input ref
 *   onChange(event) where event is a regular React.SyntheticEvent. Using this event you can get access to HTMLElement directly
 * All other props'll passed to input directly
 */
var MaskInput = /** @class */ (function (_super) {
    __extends(MaskInput, _super);
    function MaskInput(props) {
        var _this = _super.call(this, props) || this;
        _this.subscriber = function () {
            _this.showValue();
            _this.setSelection();
        };
        _this.showValue = function () {
            if (_this.state.showMask && (_this.canSetSelection || _this.props.alwaysShowMask)) {
                _this.inputEl.value = _this.input.getState().maskedValue;
                return;
            }
            _this.inputEl.value = _this.input.getState().visibleValue;
        };
        _this.setSelection = function () {
            if (!_this.canSetSelection) {
                return;
            }
            var selection = _this.input.getSelection();
            _this.inputEl.setSelectionRange(selection.start, selection.end);
            var raf = window.requestAnimationFrame ||
                window.webkitRequestAnimationFrame ||
                // @ts-ignore
                window.mozRequestAnimationFrame ||
                (function (fn) { return setTimeout(fn, 0); });
            // For android
            raf(function () { return _this.inputEl.setSelectionRange(selection.start, selection.end); });
        };
        _this.onPaste = function (e) {
            e.preventDefault();
            _this.getSelection();
            // getData value needed for IE also works in FF & Chrome
            _this.input.paste(e.clipboardData.getData('Text'));
            // Timeout needed for IE
            setTimeout(_this.setSelection, 0);
            _this.dispatchEvent(e);
        };
        _this.onChange = function (e) {
            var currentValue;
            if (_this.state.showMask && (_this.canSetSelection || _this.props.alwaysShowMask)) {
                currentValue = _this.input.getState().maskedValue;
            }
            else {
                currentValue = _this.input.getState().visibleValue;
            }
            // fix conflict by update value in mask model
            if (e.target.value !== currentValue) {
                _this.getSelection();
                _this.input.setValue(e.target.value);
                setTimeout(_this.setSelection, 0);
            }
            _this.dispatchEvent(e);
        };
        _this.onKeyPress = function (e) {
            if (e.metaKey || e.altKey || e.ctrlKey || e.key === 'Enter') {
                return;
            }
            e.preventDefault();
            _this.getSelection();
            _this.input.input(e.key || e.data || String.fromCharCode(e.which));
            _this.setSelection();
            _this.dispatchEvent(e);
        };
        _this.onKeyDown = function (e) {
            if (e.which === KEYBOARD.BACKSPACE) {
                e.preventDefault();
                _this.getSelection();
                _this.input.removePreviosOrSelected();
                _this.setSelection();
                _this.dispatchEvent(e);
            }
            if (e.which === KEYBOARD.DELETE) {
                e.preventDefault();
                _this.getSelection();
                _this.input.removeNextOrSelected();
                _this.setSelection();
                _this.dispatchEvent(e);
            }
        };
        _this.onFocus = function (e) {
            _this.canSetSelection = true;
            _this.props.onFocus && _this.props.onFocus(e);
        };
        _this.onBlur = function (e) {
            _this.canSetSelection = false;
            _this.props.onBlur && _this.props.onBlur(e);
        };
        _this.input = input_core_1.createInput({
            value: props.value || props.defaultValue || '',
            reformat: props.reformat,
            maskString: props.maskString,
            maskChar: props.maskChar || input_core_1.defaults.maskChar,
            mask: props.mask || undefined,
            maskFormat: props.maskFormat || input_core_1.defaults.maskFormat,
        });
        _this.state = {
            showMask: props.alwaysShowMask || props.showMask,
        };
        return _this;
    }
    MaskInput.prototype.componentWillReceiveProps = function (nextProps) {
        if (this.props.alwaysShowMask !== nextProps.alwaysShowMask || this.props.showMask !== nextProps.showMask) {
            this.setState({
                showMask: nextProps.alwaysShowMask || nextProps.showMask,
            });
        }
        if (nextProps.reformat !== this.props.reformat) {
            this.input.setReformat(nextProps.reformat);
        }
        if (nextProps.maskFormat && nextProps.maskFormat !== this.props.maskFormat) {
            this.input.setMaskFormat(nextProps.maskFormat);
        }
        if (nextProps.mask !== this.props.mask) {
            this.input.setMask(nextProps.mask);
        }
        if (nextProps.maskString !== this.props.maskString) {
            this.input.setMaskString(nextProps.maskString);
        }
        if (nextProps.maskChar !== this.props.maskChar) {
            this.input.setMaskChar(nextProps.maskChar);
        }
        if (nextProps.value !== this.props.value) {
            this.input.setValue(nextProps.value);
        }
    };
    MaskInput.prototype.componentDidMount = function () {
        this.input.subscribe(this.subscriber);
        this.showValue();
        this.props.getReference && this.props.getReference(this.inputEl);
    };
    MaskInput.prototype.componentWillUnmount = function () {
        this.input.unsubscribe(this.subscriber);
    };
    MaskInput.prototype.dispatchEvent = function (e) {
        this.props.onChange && this.props.onChange(e);
        var _a = this.input.getState(), maskedValue = _a.maskedValue, visibleValue = _a.visibleValue;
        this.props.onValueChange && this.props.onValueChange({ maskedValue: maskedValue, value: visibleValue });
    };
    MaskInput.prototype.getSelection = function () {
        this.input.setSelection({
            start: this.inputEl.selectionStart,
            end: this.inputEl.selectionEnd,
        });
    };
    MaskInput.prototype.keyPressPropName = function () {
        if (typeof navigator !== 'undefined' && navigator.userAgent.match(/Android/i)) {
            return 'onBeforeInput';
        }
        return 'onKeyPress';
    };
    MaskInput.prototype.render = function () {
        var _a;
        var _this = this;
        var _b = this.props, onChange = _b.onChange, 
        /* ignore unspecific props for input */
        onValueChange = _b.onValueChange, mask = _b.mask, getReference = _b.getReference, showMask = _b.showMask, maskChar = _b.maskChar, alwaysShowMask = _b.alwaysShowMask, maskFormat = _b.maskFormat, maskString = _b.maskString, reformat = _b.reformat, 
        /* ignore values */
        value = _b.value, defaultValue = _b.defaultValue, inputProps = __rest(_b, ["onChange", "onValueChange", "mask", "getReference", "showMask", "maskChar", "alwaysShowMask", "maskFormat", "maskString", "reformat", "value", "defaultValue"]);
        var keyPressEvent = (_a = {}, _a[this.keyPressPropName()] = this.onKeyPress, _a);
        return (React.createElement("input", __assign({}, inputProps, { onChange: this.onChange, onKeyDown: this.onKeyDown, onPaste: this.onPaste, onFocus: this.onFocus, onBlur: this.onBlur }, keyPressEvent, { ref: function (el) { return (_this.inputEl = el); } })));
    };
    return MaskInput;
}(React.Component));
exports.default = MaskInput;

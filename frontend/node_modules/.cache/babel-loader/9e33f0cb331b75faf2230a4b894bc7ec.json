{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar CharTypesEnum_1 = require(\"../constants/CharTypesEnum\");\n\nfunction buildInputStrings(data, mask, input, maskChar, maskString, selection) {\n  var value = [];\n  var valueIndex = 0;\n  var pastedIndex = 0;\n  var maskedValue = '';\n  var inputValuesApplied = 0;\n\n  function processMaskPartAsChar(maskPart, pastedValuesStack, item) {\n    // if user inputs value, we check it, but we don't go through all stack\n    if (pastedValuesStack && pastedValuesStack[0] === maskPart.char) {\n      pastedIndex++;\n    } else {\n      if (item && (item.char === maskPart.char || item.type !== CharTypesEnum_1.CharTypes.USER) || input) {\n        valueIndex++;\n      }\n    }\n\n    value.push({\n      char: maskPart.char,\n      type: CharTypesEnum_1.CharTypes.CHAR\n    });\n\n    if (pastedValuesStack) {\n      inputValuesApplied++;\n    }\n\n    maskedValue += maskPart.char;\n  }\n\n  function processMaskPartAsRegExp(maskPart, maskIndex, pastedValuesStack, item) {\n    var part = null; // If we have the value inputted by user, check it.\n    // We have to move through the whole stack, to find suitable\n\n    if (pastedValuesStack) {\n      var i = 0;\n\n      while (!maskPart.regexp.test(pastedValuesStack[i]) && pastedValuesStack.length > i) {\n        i++;\n        pastedIndex++;\n      }\n\n      if (pastedValuesStack.length > i) {\n        pastedIndex++;\n        inputValuesApplied++; // Ignore previous value from the input\n\n        valueIndex++;\n        part = pastedValuesStack[i];\n        value.push({\n          char: part,\n          type: CharTypesEnum_1.CharTypes.USER\n        });\n        maskedValue += part;\n      }\n    }\n\n    if (part) {\n      return;\n    } // User input doesn't have data or it's invalid.\n    // Try to apply the previous data, or change them to the placeholder\n    // if shift happened, pass excess values\n\n\n    if (item && item.type === CharTypesEnum_1.CharTypes.CHAR && data.length > valueIndex + 1) {\n      valueIndex++;\n      processMaskItem(maskPart, maskIndex);\n      return;\n    }\n\n    if (item && item.type === CharTypesEnum_1.CharTypes.USER && maskPart.regexp.test(item.char)) {\n      value.push({\n        char: item.char,\n        type: CharTypesEnum_1.CharTypes.USER\n      });\n      maskedValue += item.char;\n      valueIndex++;\n      return;\n    }\n\n    part = maskString ? maskString[maskIndex] : maskChar;\n    value.push({\n      char: part,\n      type: CharTypesEnum_1.CharTypes.MASK\n    });\n\n    if (data.length > maskIndex) {\n      valueIndex++;\n    }\n\n    maskedValue += part;\n  } // we use closures here to mutate variables, so that it increases the performance.\n\n\n  function processMaskItem(maskPart, maskIndex) {\n    var item = data.length > valueIndex ? data[valueIndex] : null;\n    var pastedValuesStack = null;\n\n    if (selection.start <= maskIndex && pastedIndex < input.length) {\n      pastedValuesStack = input.slice(pastedIndex);\n    } // process hardcoded char to the mask\n\n\n    if (maskPart.char) {\n      return processMaskPartAsChar(maskPart, pastedValuesStack, item);\n    } // text by regexp\n\n\n    if (maskPart.regexp) {\n      return processMaskPartAsRegExp(maskPart, maskIndex, pastedValuesStack, item);\n    }\n  }\n\n  mask.forEach(function (maskPart, maskIndex) {\n    processMaskItem(maskPart, maskIndex);\n  });\n  return {\n    value: value,\n    maskedValue: maskedValue,\n    inputValuesApplied: inputValuesApplied\n  };\n}\n\nexports.buildInputStrings = buildInputStrings;","map":{"version":3,"sources":["c:/Andrey/Desafio/frontend/node_modules/input-core/lib/functions/buildInputStrings.js"],"names":["Object","defineProperty","exports","value","CharTypesEnum_1","require","buildInputStrings","data","mask","input","maskChar","maskString","selection","valueIndex","pastedIndex","maskedValue","inputValuesApplied","processMaskPartAsChar","maskPart","pastedValuesStack","item","char","type","CharTypes","USER","push","CHAR","processMaskPartAsRegExp","maskIndex","part","i","regexp","test","length","processMaskItem","MASK","start","slice","forEach"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar CharTypesEnum_1 = require(\"../constants/CharTypesEnum\");\nfunction buildInputStrings(data, mask, input, maskChar, maskString, selection) {\n    var value = [];\n    var valueIndex = 0;\n    var pastedIndex = 0;\n    var maskedValue = '';\n    var inputValuesApplied = 0;\n    function processMaskPartAsChar(maskPart, pastedValuesStack, item) {\n        // if user inputs value, we check it, but we don't go through all stack\n        if (pastedValuesStack && pastedValuesStack[0] === maskPart.char) {\n            pastedIndex++;\n        }\n        else {\n            if ((item && (item.char === maskPart.char || item.type !== CharTypesEnum_1.CharTypes.USER)) || input) {\n                valueIndex++;\n            }\n        }\n        value.push({\n            char: maskPart.char,\n            type: CharTypesEnum_1.CharTypes.CHAR,\n        });\n        if (pastedValuesStack) {\n            inputValuesApplied++;\n        }\n        maskedValue += maskPart.char;\n    }\n    function processMaskPartAsRegExp(maskPart, maskIndex, pastedValuesStack, item) {\n        var part = null;\n        // If we have the value inputted by user, check it.\n        // We have to move through the whole stack, to find suitable\n        if (pastedValuesStack) {\n            var i = 0;\n            while (!maskPart.regexp.test(pastedValuesStack[i]) && pastedValuesStack.length > i) {\n                i++;\n                pastedIndex++;\n            }\n            if (pastedValuesStack.length > i) {\n                pastedIndex++;\n                inputValuesApplied++;\n                // Ignore previous value from the input\n                valueIndex++;\n                part = pastedValuesStack[i];\n                value.push({\n                    char: part,\n                    type: CharTypesEnum_1.CharTypes.USER,\n                });\n                maskedValue += part;\n            }\n        }\n        if (part) {\n            return;\n        }\n        // User input doesn't have data or it's invalid.\n        // Try to apply the previous data, or change them to the placeholder\n        // if shift happened, pass excess values\n        if (item && item.type === CharTypesEnum_1.CharTypes.CHAR && data.length > valueIndex + 1) {\n            valueIndex++;\n            processMaskItem(maskPart, maskIndex);\n            return;\n        }\n        if (item && item.type === CharTypesEnum_1.CharTypes.USER && maskPart.regexp.test(item.char)) {\n            value.push({\n                char: item.char,\n                type: CharTypesEnum_1.CharTypes.USER,\n            });\n            maskedValue += item.char;\n            valueIndex++;\n            return;\n        }\n        part = maskString ? maskString[maskIndex] : maskChar;\n        value.push({\n            char: part,\n            type: CharTypesEnum_1.CharTypes.MASK,\n        });\n        if (data.length > maskIndex) {\n            valueIndex++;\n        }\n        maskedValue += part;\n    }\n    // we use closures here to mutate variables, so that it increases the performance.\n    function processMaskItem(maskPart, maskIndex) {\n        var item = data.length > valueIndex ? data[valueIndex] : null;\n        var pastedValuesStack = null;\n        if (selection.start <= maskIndex && pastedIndex < input.length) {\n            pastedValuesStack = input.slice(pastedIndex);\n        }\n        // process hardcoded char to the mask\n        if (maskPart.char) {\n            return processMaskPartAsChar(maskPart, pastedValuesStack, item);\n        }\n        // text by regexp\n        if (maskPart.regexp) {\n            return processMaskPartAsRegExp(maskPart, maskIndex, pastedValuesStack, item);\n        }\n    }\n    mask.forEach(function (maskPart, maskIndex) {\n        processMaskItem(maskPart, maskIndex);\n    });\n    return {\n        value: value,\n        maskedValue: maskedValue,\n        inputValuesApplied: inputValuesApplied,\n    };\n}\nexports.buildInputStrings = buildInputStrings;\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar defineMaskList_1 = require(\"./functions/defineMaskList\");\n\nvar inputValue_1 = require(\"./functions/inputValue\");\n\nvar removeSelectedRange_1 = require(\"./functions/removeSelectedRange\");\n\nvar CharTypesEnum_1 = require(\"./constants/CharTypesEnum\");\n\nexports.defaults = {\n  maskFormat: [{\n    str: '0',\n    regexp: /[0-9]/\n  }, {\n    str: '*',\n    regexp: /./\n  }, {\n    str: 'a',\n    regexp: /[a-zA-Z]/\n  }],\n  maskChar: '',\n  showMask: false,\n  removeSelectedRange: removeSelectedRange_1.default\n};\n\nexports.createInput = function (params) {\n  var maskString = params.maskString,\n      reformat = params.reformat,\n      _a = params.maskFormat,\n      maskFormat = _a === void 0 ? exports.defaults.maskFormat : _a,\n      _b = params.maskChar,\n      maskChar = _b === void 0 ? exports.defaults.maskChar : _b;\n\n  if (!reformat && !params.mask) {\n    reformat = function (params) {\n      var str = params.value.map(function (item) {\n        return item.char;\n      }).join('');\n      return {\n        value: params.value,\n        visibleValue: str,\n        maskedValue: str,\n        selection: params.selection\n      };\n    };\n  } else if (reformat) {\n    params.mask = null;\n  }\n\n  if (maskString && maskString.length !== params.mask.length) {\n    throw new Error('maskString must have same length as mask');\n  }\n\n  if (maskChar.length > 1) {\n    throw new Error('maskChar must have only 1 char');\n  }\n\n  var maskFormatMap;\n  var selection = {\n    start: 0,\n    end: 0\n  };\n  var value;\n  var maskedValue;\n  var visibleValue;\n  var mask;\n  var callbacks = [];\n  var interfaceMethods = {\n    subscribe: function (callback) {\n      callbacks.push(callback);\n    },\n    unsubscribe: function (callback) {\n      callbacks = callbacks.filter(function (item) {\n        return item !== callback;\n      });\n    },\n    setMaskFormat: function (maskFormat) {\n      maskFormatMap = maskFormat.reduce(function (store, item) {\n        store[item.str] = item;\n        return store;\n      }, {});\n    },\n    setValue: function (data) {\n      var result;\n\n      if (reformat) {\n        result = reformat({\n          value: data,\n          selection: selection\n        });\n      } else {\n        var dataList = void 0;\n\n        if (Array.isArray(data)) {\n          dataList = data;\n        } else {\n          dataList = [];\n\n          for (var i = 0; i < data.length; i++) {\n            dataList.push({\n              char: data[i],\n              type: CharTypesEnum_1.CharTypes.USER\n            });\n          }\n        }\n\n        result = inputValue_1.default({\n          data: dataList,\n          selection: selection,\n          mask: mask,\n          maskChar: maskChar,\n          maskString: maskString\n        });\n      }\n\n      applyChanges(result);\n    },\n    setSelection: function (newSelection) {\n      selection = newSelection;\n    },\n    getSelection: function () {\n      return {\n        start: selection.start,\n        end: selection.end\n      };\n    },\n    backspace: function () {\n      interfaceMethods.removePreviosOrSelected();\n    },\n    removePreviosOrSelected: function () {\n      if (selection.start === selection.end) {\n        selection.start = selection.end - 1;\n\n        if (selection.start < 0) {\n          selection.start = 0;\n        }\n      }\n\n      interfaceMethods.input('');\n    },\n    removeNextOrSelected: function () {\n      if (selection.start === selection.end) {\n        selection.end++;\n      }\n\n      interfaceMethods.input('');\n    },\n    getState: function () {\n      return {\n        value: value,\n        maskedValue: maskedValue,\n        visibleValue: visibleValue,\n        selection: selection\n      };\n    },\n    setMask: function (newMask) {\n      mask = defineMaskList_1.default(newMask, maskFormatMap);\n      interfaceMethods.setValue(value);\n    },\n    setMaskChar: function (newMaskChar) {\n      if (maskChar.length > 1) {\n        throw new Error('maskChar must have only 1 char');\n      }\n\n      maskChar = newMaskChar;\n      interfaceMethods.setValue(value);\n    },\n    setMaskString: function (newMaskString) {\n      if (newMaskString && newMaskString.length !== mask.length) {\n        throw new Error('maskString must have the same length as mask');\n      }\n\n      maskString = newMaskString;\n      interfaceMethods.setValue(value);\n    },\n    setReformat: function (newReformat) {\n      reformat = newReformat;\n      interfaceMethods.setValue(value);\n    },\n    paste: function (value) {\n      interfaceMethods.input(value);\n    },\n    input: function (input) {\n      var result;\n\n      if (reformat) {\n        result = reformat({\n          value: value,\n          input: input,\n          selection: selection\n        });\n      } else {\n        var tmpValue = removeSelectedRange_1.default({\n          value: value,\n          selection: selection,\n          maskChar: maskChar,\n          maskString: maskString\n        });\n        selection.end = selection.start;\n        result = inputValue_1.default({\n          data: tmpValue,\n          input: input,\n          selection: selection,\n          mask: mask,\n          maskChar: maskChar,\n          maskString: maskString\n        });\n      }\n\n      applyChanges(result);\n    }\n  };\n\n  function applyChanges(result) {\n    var oldMaskedValue = maskedValue;\n    var oldVisibleValue = visibleValue;\n    var oldSelection = selection;\n    value = result.value;\n    maskedValue = result.maskedValue;\n    visibleValue = result.visibleValue;\n    interfaceMethods.setSelection(result.selection);\n\n    if (oldMaskedValue !== maskedValue || oldVisibleValue !== visibleValue || oldSelection.start !== selection.start || oldSelection.end !== selection.end) {\n      notify();\n    }\n  }\n\n  function notify() {\n    var state = interfaceMethods.getState();\n    callbacks.forEach(function (callback) {\n      callback(state);\n    });\n  }\n\n  interfaceMethods.setMaskFormat(maskFormat);\n  mask = defineMaskList_1.default(params.mask, maskFormatMap);\n  interfaceMethods.setValue(params.value);\n  return interfaceMethods;\n};","map":{"version":3,"sources":["C:/Andrey/Desafio/frontEnd/node_modules/input-core/lib/index.js"],"names":["Object","defineProperty","exports","value","defineMaskList_1","require","inputValue_1","removeSelectedRange_1","CharTypesEnum_1","defaults","maskFormat","str","regexp","maskChar","showMask","removeSelectedRange","default","createInput","params","maskString","reformat","_a","_b","mask","map","item","char","join","visibleValue","maskedValue","selection","length","Error","maskFormatMap","start","end","callbacks","interfaceMethods","subscribe","callback","push","unsubscribe","filter","setMaskFormat","reduce","store","setValue","data","result","dataList","Array","isArray","i","type","CharTypes","USER","applyChanges","setSelection","newSelection","getSelection","backspace","removePreviosOrSelected","input","removeNextOrSelected","getState","setMask","newMask","setMaskChar","newMaskChar","setMaskString","newMaskString","setReformat","newReformat","paste","tmpValue","oldMaskedValue","oldVisibleValue","oldSelection","notify","state","forEach"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar defineMaskList_1 = require(\"./functions/defineMaskList\");\nvar inputValue_1 = require(\"./functions/inputValue\");\nvar removeSelectedRange_1 = require(\"./functions/removeSelectedRange\");\nvar CharTypesEnum_1 = require(\"./constants/CharTypesEnum\");\nexports.defaults = {\n    maskFormat: [\n        {\n            str: '0',\n            regexp: /[0-9]/,\n        },\n        {\n            str: '*',\n            regexp: /./,\n        },\n        {\n            str: 'a',\n            regexp: /[a-zA-Z]/,\n        },\n    ],\n    maskChar: '',\n    showMask: false,\n    removeSelectedRange: removeSelectedRange_1.default,\n};\nexports.createInput = function (params) {\n    var maskString = params.maskString, reformat = params.reformat, _a = params.maskFormat, maskFormat = _a === void 0 ? exports.defaults.maskFormat : _a, _b = params.maskChar, maskChar = _b === void 0 ? exports.defaults.maskChar : _b;\n    if (!reformat && !params.mask) {\n        reformat = function (params) {\n            var str = params.value.map(function (item) { return item.char; }).join('');\n            return {\n                value: params.value,\n                visibleValue: str,\n                maskedValue: str,\n                selection: params.selection,\n            };\n        };\n    }\n    else if (reformat) {\n        params.mask = null;\n    }\n    if (maskString && maskString.length !== params.mask.length) {\n        throw new Error('maskString must have same length as mask');\n    }\n    if (maskChar.length > 1) {\n        throw new Error('maskChar must have only 1 char');\n    }\n    var maskFormatMap;\n    var selection = { start: 0, end: 0 };\n    var value;\n    var maskedValue;\n    var visibleValue;\n    var mask;\n    var callbacks = [];\n    var interfaceMethods = {\n        subscribe: function (callback) {\n            callbacks.push(callback);\n        },\n        unsubscribe: function (callback) {\n            callbacks = callbacks.filter(function (item) { return item !== callback; });\n        },\n        setMaskFormat: function (maskFormat) {\n            maskFormatMap = maskFormat.reduce(function (store, item) {\n                store[item.str] = item;\n                return store;\n            }, {});\n        },\n        setValue: function (data) {\n            var result;\n            if (reformat) {\n                result = reformat({\n                    value: data,\n                    selection: selection,\n                });\n            }\n            else {\n                var dataList = void 0;\n                if (Array.isArray(data)) {\n                    dataList = data;\n                }\n                else {\n                    dataList = [];\n                    for (var i = 0; i < data.length; i++) {\n                        dataList.push({ char: data[i], type: CharTypesEnum_1.CharTypes.USER });\n                    }\n                }\n                result = inputValue_1.default({ data: dataList, selection: selection, mask: mask, maskChar: maskChar, maskString: maskString });\n            }\n            applyChanges(result);\n        },\n        setSelection: function (newSelection) {\n            selection = newSelection;\n        },\n        getSelection: function () {\n            return {\n                start: selection.start,\n                end: selection.end,\n            };\n        },\n        backspace: function () {\n            interfaceMethods.removePreviosOrSelected();\n        },\n        removePreviosOrSelected: function () {\n            if (selection.start === selection.end) {\n                selection.start = selection.end - 1;\n                if (selection.start < 0) {\n                    selection.start = 0;\n                }\n            }\n            interfaceMethods.input('');\n        },\n        removeNextOrSelected: function () {\n            if (selection.start === selection.end) {\n                selection.end++;\n            }\n            interfaceMethods.input('');\n        },\n        getState: function () {\n            return {\n                value: value,\n                maskedValue: maskedValue,\n                visibleValue: visibleValue,\n                selection: selection,\n            };\n        },\n        setMask: function (newMask) {\n            mask = defineMaskList_1.default(newMask, maskFormatMap);\n            interfaceMethods.setValue(value);\n        },\n        setMaskChar: function (newMaskChar) {\n            if (maskChar.length > 1) {\n                throw new Error('maskChar must have only 1 char');\n            }\n            maskChar = newMaskChar;\n            interfaceMethods.setValue(value);\n        },\n        setMaskString: function (newMaskString) {\n            if (newMaskString && newMaskString.length !== mask.length) {\n                throw new Error('maskString must have the same length as mask');\n            }\n            maskString = newMaskString;\n            interfaceMethods.setValue(value);\n        },\n        setReformat: function (newReformat) {\n            reformat = newReformat;\n            interfaceMethods.setValue(value);\n        },\n        paste: function (value) {\n            interfaceMethods.input(value);\n        },\n        input: function (input) {\n            var result;\n            if (reformat) {\n                result = reformat({ value: value, input: input, selection: selection });\n            }\n            else {\n                var tmpValue = removeSelectedRange_1.default({ value: value, selection: selection, maskChar: maskChar, maskString: maskString });\n                selection.end = selection.start;\n                result = inputValue_1.default({ data: tmpValue, input: input, selection: selection, mask: mask, maskChar: maskChar, maskString: maskString });\n            }\n            applyChanges(result);\n        },\n    };\n    function applyChanges(result) {\n        var oldMaskedValue = maskedValue;\n        var oldVisibleValue = visibleValue;\n        var oldSelection = selection;\n        value = result.value;\n        maskedValue = result.maskedValue;\n        visibleValue = result.visibleValue;\n        interfaceMethods.setSelection(result.selection);\n        if (oldMaskedValue !== maskedValue ||\n            oldVisibleValue !== visibleValue ||\n            oldSelection.start !== selection.start ||\n            oldSelection.end !== selection.end) {\n            notify();\n        }\n    }\n    function notify() {\n        var state = interfaceMethods.getState();\n        callbacks.forEach(function (callback) {\n            callback(state);\n        });\n    }\n    interfaceMethods.setMaskFormat(maskFormat);\n    mask = defineMaskList_1.default(params.mask, maskFormatMap);\n    interfaceMethods.setValue(params.value);\n    return interfaceMethods;\n};\n"]},"metadata":{},"sourceType":"script"}